---
title: "Step B1. Sampling Component and Variable Activation Report"
author: "Aidan Neher"
format: html
editor: visual
---

## About the simulated data

With `set.seed(1)`, data from BIP manuscript scenario 1 was simulated.

## Results from original `BIP()` vs. step B1

Defaults used for original `BIP()`: sample = 5000, burn-in = 1000

Step B1 results taken from in-progress sampling. Thus, we have sample = 2500, burn-in = 1000.

```{r}
#| echo: false
bip_0 <- readRDS("data/2023-07-03_simulation_BIP_results.rds")
simulation_results <- readRDS("data/2023-07-03_simulation_results.rds")
bip_0$CompoSelMean
```

```{r}
#| echo: false
library(tidyverse)
library(gridExtra)

gamma_file_names <- paste0("data/2023-07-19Gamma_seed_", 1:5, ".rds")
gamma_results <- lapply(gamma_file_names, readRDS)


gamma_result <- readRDS("data/2023-07-19Gamma_seed_5.rds")
eta_result <- readRDS("data/2023-07-19Eta_seed_5.rds")

burnin <- 1000
sample <- 2500 # define how large a sample we have thus far
n_iterations <- burnin + sample
n_views <- 3
n_seeds <- 5
r <- 4

get_gamma_trace_plot <- function(gamma_result_m, n_iterations) {
  gamma_m <- gamma_result_m[, 1:n_iterations] %>% 
    t() %>% as.data.frame() %>%
    mutate(iter = 1:n_iterations) %>%
    gather(key = "component", value = "gamma", -iter)
  gamma_m_p <- ggplot(data = gamma_m, aes(x=iter, y=gamma, color = component)) +
    geom_point()
  return(gamma_m_p)
}

get_gamma_trace_plots <- function(gamma_result_seed, n_iterations) {
  return(lapply(gamma_result_seed, get_gamma_trace_plot, n_iterations))
}

gamma_trace_plots <- lapply(gamma_results, get_gamma_trace_plots, n_iterations)

# flatten list for grid.arrange
# gamma_trace_plots_flat_list <- list()
# for (s in 1:n_seeds) {
#   for (m in 1:n_views) {
#     gamma_trace_plots_flat_list[[s*m]] <- gamma_trace_plots[[s]][[m]]
#   }
# }
# 
# # Add row and column titles
# # row_titles <- paste("seed", 1:n_seeds)
# # col_titles <- paste("view", 1:n_views)
# # names(gamma_trace_plots_flat_list) <- paste(row_titles, col_titles, sep="_")
# 
# do.call(grid.arrange, c(gamma_trace_plots_flat_list, nrow = n_seeds, ncol = n_views))

get_gamma_seed_plot <- function(gamma_trace_plot_seed, n_views) {
  do.call(grid.arrange, c(gamma_trace_plot_seed, ncol = n_views))
} 

gamma_seed_plots <- lapply(gamma_trace_plots, get_gamma_seed_plot, n_views)



gamma_plots_one_page <- do.call(grid.arrange, 
                                c(gamma_seed_plots, nrow = n_seeds))

print(gamma_plots_one_page)

# # calculate mpp for the lth component in the mth view
# get_gamma_mpp_m <- function(gamma_m, start = burnin+1, end = burnin+sample) {
#   mpps <- apply(gamma_m[, start:end], 1, sum) / ncol(gamma_m)
#   return(mpps)
# }
# 
# get_gamma_mpp <- function(view_list, sample, burnin) {
#   sapply(view_list, get_gamma_mpp_m, start = burnin+1, end = burnin+sample) %>% t()
# }
# 
# get_gamma_mpp(view_list_2, sample, burnin)
# 
# get_eta_mpp_m_j <- function(j, view_list_m, start = burnin+1, end = burnin+sample) {
#   eta_by_component <- view_list_m$Eta_m[, j, start:end]
#   mpp_m_j <- apply(eta_by_component, 1, sum) / ncol(eta_by_component)
#   return(mpp_m_j)
# }
# 
# get_eta_mpp_m <- function(view_list_m, burnin, sample) {
#   p_m <- dim(view_list_m$Eta_m)[2] # TODO remove workaround by adding p_m to each element of view_list
#   sapply(1:p_m, get_eta_mpp_m_j, view_list_m, start = burnin+1, end = burnin + sample) %>% t()
# }
# 
# var_sel_mean <- lapply(view_list_2, get_eta_mpp_m, burnin, sample)
# 
# get_var_sel_mean_global_j <- function(j, view_list_m, burnin, sample) {
#   eta_global_j <- view_list_m$Eta_m[, j, (burnin+1):(burnin+sample)] %>% colSums() 
#   eta_global_j <- ifelse(eta_global_j>0, 1, 0)
#   var_sel_mean_global_j <- sum(eta_global_j) / length(eta_global_j)
#   return(var_sel_mean_global_j)
# }
# 
# get_mpp_global_m <- function(view_list_m, burnin, sample) {
#   p_m <- dim(view_list_m$Eta_m)[2] # TODO remove workaround by adding p_m to each element of view_list
#   sapply(1:p_m, get_var_sel_mean_global_j, view_list_m, burnin, sample)
# }
# 
# var_sel_mean_global <- lapply(view_list_2, get_mpp_global_m, burnin, sample)
# 
# print("Omics features selected globally by original BIP():")
# which(bip_0$VarSelMeanGlobal[[1]]>0.5)
# which(bip_0$VarSelMeanGlobal[[2]]>0.5)
# 
# print("Omics features selected globally by current version:")
# which(var_sel_mean_global[[1]]>0.5)
# which(var_sel_mean_global[[2]]>0.5)
```

<!-- Here's a trace plot of the MPP of the first 10 variables in the 1st view. -->

```{r}
#| echo: false 
# m <- 1
# set.seed(1)
# features_to_plot <- 1:10
# j <- features_to_plot[1]
# 
# get_cumulative_eta_mpp_m_j <- function(j, view_list_m, start = burnin+1, end = burnin+sample) {
#   eta_by_component <- view_list_m$Eta_m[, j, start:end]
#   eta_cumulative <- apply(eta_by_component, 1, cumsum) # TODO use ifelse here?
#   results <- numeric(nrow(eta_cumulative))
#   for (j in 1:nrow(eta_cumulative)) {
#     results[j] <- sum(eta_cumulative[j, ]) / j
#   }
#   return(results)
# }
# cumulative_var_sel_mpp_j <- get_cumulative_eta_mpp_m_j(j, view_list_2[[m]], start = burnin+1, end = burnin+sample)
# 
# results <- sapply(1:10, get_cumulative_eta_mpp_m_j, view_list_2[[m]]) %>% as.data.frame() %>%
#   mutate(iter_id = 1:sample) %>% gather(key = "variable", value = "cum_var_selection", -iter_id)
# ggplot(results, aes(x = iter_id, y = cum_var_selection, color = variable)) + geom_point()
```

## Run Time

Step B1 alone is slow...

## Questions

-   How might I decide if my code is doing what it's meant to do?
-   How might I approach these tests/ simulation studies in a meaningful way?
-   How might I speed the code? Parallel compuation and conversion to Rcpp...