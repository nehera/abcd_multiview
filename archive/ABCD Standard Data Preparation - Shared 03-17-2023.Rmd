---
title: "Standard ABCD Data Preparation"
author: "Andrea Wiglesworth"
date: "2023-02-04"
output: html_document
---

# To Do

1. Decide how we want to code the "Missing_race" variables -- individuals who endorsed none of the race variables (but may have endorsed the ethnicity variable), or only individuals who did not endorse the race OR ethnicity variables? (see Chunk 6 - Kelly will clean this whole thing up once it's decided!)

2. Add in a user-inputted argument about whether or not baseline demo vars should be carried forward to all subsequent time points re: convo 3/3/2023 in ABCD meeting with Tim? (See Chunk 5 for where I think this would be done)

3. Add in argument to enable different desired time points for wide and long formats? Or just have people re-run?

4. Delete sections marked as "Begin Deletion Section" to "End Deletion Section" once Andrea gives the go-ahead

5. Clean up race/ethnicity approach using a `tidyverse` solution - Mark will do this eventually?

6. Decide how to keep the code - keep it as an .Rmd file, or as a standard .R file so it's easier for people to source without creating an .html document? (Although perhaps that's something people would want, something noting exactly what's been done?)

# Code 

User Input (added by Kelly with the idea that hopefully if this works right, the rest of the code can be ran without the user needing to do anything, hopefully averting errors). Note for now, people will just input what they want here and then all other chunks still have to be run. If we switch this from a .Rmd file to a regular .R file, we could just have the user input be the first lines at the top and then the user could source the code and generate the output automatically. We could also think about wrapping this all up into a function so that certain defaults (e.g., NULL for most variables) can be set. If we want to use it on the cluster we could also set it up to take command-line inputs, but given that it's currently pulling everything from Box and is only outputting tabulated data I don't think that's necessary. Just putting ideas out there for input - I don't want to commandeer things! Anyway, user input:
```{r user-input}
# Location of "ABCD Standard Data Preparation" Box Directory (on local computer) - if NULL, will assume that the current working dir is the '*/Box/ABCD STUDY/ABCD Standard Data Preparation' directory
# Note that example below is based on a Mac directory
data_dir <- '/Users/USERNAME/Library/CloudStorage/Box-Box/ABCD STUDY/ABCD Standard Data Preparation/' # ['path',NULL]

# Location of desired output directory of created csv file - if NULL, will output file into current working directory
out_dir <- '/Users/USERNAME/Library/CloudStorage/Box-Box/ABCD STUDY/New Project' # ['path',NULL]

# Date you want used in output name of csv file - if NULL, will use output from Sys.Date() (current date)
out_date <- '2023-03-03' # ['date_string',NULL]

# Initials or other string you want used in output name of csv file - no NULL option here, have to put in some sort of string (though we could create a default for this?)
out_initials <- 'KAD' # ['initials_string']

# Do you also want to output a wide format data file?
wide <- TRUE # [TRUE,FALSE]

# What variables do you want to output in the wide format?
# If only a subset is desired, include string giving the name of each variable combined into a vector as c('var_1','var_2','var_3') 
# e.g., wide_vars <- c('eventname','demo_sex_v2','demo_gender_id_v2','demo_prnt_marital_v2')
# See codebook for variable labels: https://docs.google.com/spreadsheets/d/1uHRrXASaxtZbRAeJvPJktqxyDkPdA2_WgxYdLTjhK1Q/edit?usp=sharing
# If NULL, will use ALL variables included in the regular long output
wide_vars <- NULL 
# Note that this currently assumes the same time points are desired for long and wide formats - does this make sense?

# What time points do you want to output? Put the string provided for all desired timepoints into a vector using c('timepoint1_name','timepoint2_name') etc.
timepoint_list <- c("baseline_year_1_arm_1","1_year_follow_up_y_arm_1") # ['baseline_year_1_arm_1','6_month_follow_up_arm_1','1_year_follow_up_y_arm_1','18_month_follow_up_arm_1','2_year_follow_up_y_arm_1','30_month_follow_up_arm_1','3_year_follow_up_y_arm_1','42_month_follow_up_arm_1']
```

Load Necessary Packages
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(purrr)
library(tidyr)
```

USE ONLINE CODEBOOK TO FIND THE LABELS FOR THE VARIABLES: 
https://docs.google.com/spreadsheets/d/1uHRrXASaxtZbRAeJvPJktqxyDkPdA2_WgxYdLTjhK1Q/edit?usp=sharing

Load Data Files
```{r}
# KAD 3/3/2022
# Set directory of Box directory to read datafiles in from based on above input
# Recall that NULL assumes the current wd is the '*/Box/ABCD STUDY/ABCD Standard Data Preparation' dir
if(!is.null(data_dir)){
  setwd(data_dir)
}

#Standard files for most studies
demog_bl <- read.csv("pdem02.csv") #Baseline Demographics (Demographic Variables)
demog_long <- read.csv("abcd_lpds01.csv") #Longitudinal Demographics (Demographic Variables)
puberty <- read.csv("abcd_ssphp01.csv") #Pubertal Stage (Demographic Variables)
site <- read.csv("abcd_lt01.csv") #Site ID (ABCD Study Design Variables)
study_covars <- read.csv("acspsw03.csv") #Family ID and Propensity Weights (ABCD Study Design Variables)
mri <- read.csv("abcd_mri01.csv") #MRI Platform information (Neuroimaging Variables)
fsqc <- read.csv("freesqc01.csv") #MRI Freesurfer quality score (Neuroimaging Variables)

#Standard files for clinical data
cbcl <- read.csv("abcd_cbcls01.csv") #CBCL
ksad_p <- read.csv("abcd_ksad01.csv") #Parent ksads
ksad_t <- read.csv("abcd_ksad501.csv") #Teen ksads

#Delete first row (description of the variables)
demog_bl <- demog_bl[-1,]
demog_long <- demog_long[-1,]
puberty <- puberty[-1,]
site <- site[-1,]
study_covars <- study_covars[-1,]
mri <- mri[-1,]
fsqc <- fsqc[-1,]
cbcl <- cbcl[-1,]
ksad_p <- ksad_p[-1,]
ksad_t <- ksad_t[-1,]
```

Select Relevant Variables
```{r}
demog_bl <- demog_bl %>%
  select(subjectkey, eventname, demo_sex_v2, demo_gender_id_v2, demo_race_a_p___10,
         demo_race_a_p___11,demo_race_a_p___12, demo_race_a_p___13, demo_race_a_p___14,
         demo_race_a_p___15, demo_race_a_p___16, demo_race_a_p___17, demo_race_a_p___18,
         demo_race_a_p___19, demo_race_a_p___20, demo_race_a_p___21, demo_race_a_p___22,
         demo_race_a_p___23, demo_race_a_p___24, demo_race_a_p___25,demo_race_a_p___77, 
         demo_race_a_p___99, demo_ethn_v2, demo_prnt_marital_v2, demo_prnt_ed_v2, demo_prtnr_ed_v2,
         demo_comb_income_v2, demo_fam_exp1_v2, demo_fam_exp2_v2, demo_fam_exp3_v2,
         demo_fam_exp4_v2, demo_fam_exp5_v2, demo_fam_exp6_v2, demo_fam_exp7_v2, demo_roster_v2)

demog_long <- demog_long %>%
  select(subjectkey, eventname, interview_age, demo_gender_id_v2_l, demo_comb_income_v2_l, demo_roster_v2_l)

puberty <- puberty %>%
  select(subjectkey, eventname, pds_p_ss_male_category_2, pds_p_ss_female_category_2)

site <- site %>%
  select(subjectkey, eventname, site_id_l)

study_covars <- study_covars %>%
  select(subjectkey, eventname, rel_family_id, rel_group_id)
  
mri <- mri %>%
  select(subjectkey, eventname, mri_info_manufacturer)

fsqc <- fsqc %>%
  select(subjectkey, eventname, fsqc_qc)

cbcl <- cbcl %>%
  select(subjectkey, eventname, cbcl_scr_syn_internal_r, cbcl_scr_syn_external_r, cbcl_scr_syn_totprob_r,
         cbcl_scr_dsm5_depress_r, cbcl_scr_dsm5_anxdisord_r, cbcl_scr_dsm5_adhd_r,
         cbcl_scr_syn_internal_t, cbcl_scr_syn_external_t, cbcl_scr_syn_totprob_t,
         cbcl_scr_dsm5_depress_t, cbcl_scr_dsm5_anxdisord_t, cbcl_scr_dsm5_adhd_t)

ksad_p <- ksad_p %>%
  select(subjectkey, eventname, ksads_23_946_p, ksads_23_957_p, ksads_23_954_p, ksads_23_965_p, ksads_23_956_p,
         ksads_23_945_p, ksads_23_950_p, ksads_23_961_p, ksads_23_947_p, ksads_23_958_p, ksads_23_948_p,
         ksads_23_959_p, ksads_23_949_p, ksads_23_960_p, ksads_23_952_p, ksads_23_963_p, ksads_23_951_p,
         ksads_23_962_p, ksads_23_953_p, ksads_23_964_p)

ksad_t <- ksad_t %>%
  select(subjectkey, eventname, ksads_23_945_t, ksads_23_946_t, ksads_23_947_t, ksads_23_948_t, ksads_23_949_t,
         ksads_23_950_t, ksads_23_951_t, ksads_23_952_t, ksads_23_953_t, ksads_23_954_t, ksads_23_956_t, 
         ksads_23_957_t, ksads_23_958_t, ksads_23_959_t, ksads_23_960_t, ksads_23_961_t, ksads_23_962_t,
         ksads_23_963_t, ksads_23_964_t, ksads_23_965_t)

```


Merge into single file and replace missing data codes with NA (Can change this if you do not want that)
```{r}
files <- list(demog_bl, demog_long, puberty, site, study_covars, mri, fsqc, cbcl, ksad_p, ksad_t)

abcd_data <- files %>% reduce(full_join, by = c("subjectkey", "eventname"))
# KAD 3/3/2023: Note that the above is where we'd have to change it to fill the demo variables into all time points, as discussed in today's meeting with Tim
# Should I add a user input to ask if they want to do this? Or should we automatically do it? Or let people resolve it themselves?

# MF: 3/10/23 Check if the lines below yield the same intended result. This bypasses the problem with the dplyr update
abcd_data <- abcd_data %>%
  mutate(across(where(is.numeric), ~na_if(.,777))) %>%
  mutate(across(where(is.numeric), ~na_if(.,999))) %>%
  mutate(across(where(is.numeric), ~na_if(.,555))) %>%
  mutate(across(where(is.numeric), ~na_if(.,888))) %>%
  mutate(across(where(is.character), ~na_if(.,"777"))) %>%
  mutate(across(where(is.character), ~na_if(.,"999"))) %>%
  mutate(across(where(is.character), ~na_if(.,"555"))) %>%
  mutate(across(where(is.character), ~na_if(.,"888"))) %>%
  mutate(across(where(is.character), ~na_if(.,""))) 
# KAD 3/13/23: Added the last line to fill in blank values as NA
  
##### Begin deletion section #####
View(abcd_data)
# KAD 3/3/2023: eventually we might want to comment this out or add it as a call at the very end once the data is complete for people to view?
##### End deletion section #####
```


Recode Race and Puberty Variables 
```{r}
abcd_data$White_race <- abcd_data$demo_race_a_p___10
abcd_data$Black_race <- abcd_data$demo_race_a_p___11
abcd_data$AIAN_race <- abcd_data$demo_race_a_p___12
abcd_data$AIAN_race[abcd_data$demo_race_a_p___13 == 1] <- 1
abcd_data$NHPI_race <- abcd_data$demo_race_a_p___14
abcd_data$NHPI_race[abcd_data$demo_race_a_p___15 == 1] <- 1
abcd_data$NHPI_race[abcd_data$demo_race_a_p___16 == 1] <- 1
abcd_data$NHPI_race[abcd_data$demo_race_a_p___17 == 1] <- 1
abcd_data$Asian_race <- abcd_data$demo_race_a_p___18
abcd_data$Asian_race[abcd_data$demo_race_a_p___19 == 1] <- 1
abcd_data$Asian_race[abcd_data$demo_race_a_p___20 == 1] <- 1
abcd_data$Asian_race[abcd_data$demo_race_a_p___21 == 1] <- 1
abcd_data$Asian_race[abcd_data$demo_race_a_p___22 == 1] <- 1
abcd_data$Asian_race[abcd_data$demo_race_a_p___23 == 1] <- 1
abcd_data$Asian_race[abcd_data$demo_race_a_p___24 == 1] <- 1
abcd_data$Other_race <- abcd_data$demo_race_a_p___25 
abcd_data$Missing_race <- abcd_data$demo_race_a_p___77
abcd_data$Missing_race[abcd_data$demo_race_a_p___99 == 1] <- 1
abcd_data$Missing_race[abcd_data$White_race == 1] <- 0
abcd_data$Missing_race[abcd_data$Black_race == 1] <- 0
abcd_data$Missing_race[abcd_data$AIAN_race == 1] <- 0
abcd_data$Missing_race[abcd_data$NHPI_race == 1] <- 0
abcd_data$Missing_race[abcd_data$Asian_race == 1] <- 0
abcd_data$Missing_race[abcd_data$Other_race == 1] <- 0
abcd_data$Indigenous_race <- abcd_data$AIAN_race
abcd_data$Indigenous_race[abcd_data$NHPI_race == 1] <- 1 #Indigenous may be desired instead of AIAN and NHPI when sample sizes are limited
abcd_data$demo_ethn_v2 <- dplyr::recode(abcd_data$demo_ethn_v2, "2" = "0")
abcd_data$Missing_race[abcd_data$demo_ethn_v2 == "1"] <- 0 #Individuals who do not have race or ethnicity data thus might need excluded when analyses control for race/ethnicity
# KAD 2/23: I think that you're totally right, but since for the race/eth vars people who did not endorse it are all coded as 0 (and not NA), this doesn't account for people who just didn't answer anything at all, including questions 77 and 99. I counted 25 such people who endorsed NO race variable, including missing, and 12 who didn't endorse any race variable OR the ethnicity variable. So it depends how you want to think about that
# (Although the ethnicity variable is different in that it does actually count people who didn't answer as NA, since it was a singular question, so this is also something important to think about in analyses - in most base R functions these individuals would be dropped)
# So anyway, I might propose adding in a variable that checks if people didn't endorse ANY category (either just race or race + ethnicity)
# This is messy and I'll write something cleaner but this is a modified version (since the race variables are character strings here) of the code I used to do this check previously
race_eth_vars <- c("White_race","Black_race","AIAN_race","NHPI_race","Asian_race","Other_race","demo_ethn_v2")
# Note that you could include or not include Missing_race -- they're already marked as 1 anyway so it doesn't really matter
# Might be useful not to if you want to use this new variable for something else (like streamlining the checks above whether anyone who endorsed the missing race questions (77 and 99) also endorsed another race variable), or might be more useful to include it, depending on what you want to do with it
# And again, need to think about if ethnicity should be included her or not since it does already have its own missingness info
test_race_eth_matrix <- abcd_data[,race_eth_vars] # Quick, dirty way to easily convert all to numeric
test_race_eth_matrix <- apply(test_race_eth_matrix, 2, as.numeric)
abcd_data$race_eth_any <- rowSums(test_race_eth_matrix) # Get total -- will be 0 if none are endorsed
# Now turn into a binary variable
abcd_data$race_binary <- ifelse(abcd_data$race_eth_any == 0, 0, 1) # If => 1, 1, otherwise if 0, 0
# Now mark as missing
abcd_data$Missing_race[which(abcd_data$race_binary == 0)] <- 1

##### Begin deletion section #####
# abcd_data$sex <- abcd_data$demo_sex_v2[abcd_data$eventname=="baseline_year_1_arm_1"]
# Mark's revision
#abcd_data$sex <- abcd_data$demo_sex_v2

# Mark's revision
# abcd_data$demo_sex_v2 %>% table() # Check that the only values are 1, 2, and 3
##### End deletion section #####

abcd_data <- abcd_data %>%
  mutate(pubertal_status = if_else(demo_sex_v2 == '1' | demo_sex_v2 == '3',
                                  pds_p_ss_male_category_2, # Set to this if the condition above is TRUE
                                  pds_p_ss_female_category_2)) # Otherwise set to this 


#Recoding to indicate highest education between parent and partner
abcd_data$demo_prnt_ed_v2 <- as.integer(abcd_data$demo_prnt_ed_v2)
abcd_data$demo_prtnr_ed_v2 <- as.integer(abcd_data$demo_prtnr_ed_v2)

abcd_data <- abcd_data %>%
  mutate(highest_demo_ed = if_else(is.na(demo_prtnr_ed_v2),
                                   demo_prnt_ed_v2, 
                                   if_else(demo_prnt_ed_v2 > demo_prtnr_ed_v2,
                                           demo_prnt_ed_v2, demo_prtnr_ed_v2)))

```


Create STB and NSSI variables
```{r}

abcd_data<- abcd_data %>%
	    mutate(SI_ever_t = factor(if_else(0 < (ksads_23_946_t==1) +
	                                      (ksads_23_947_t==1) + (ksads_23_948_t==1) + (ksads_23_949_t==1) +
	                                      (ksads_23_950_t==1), "present", 
	                                    if_else(0 < (ksads_23_957_t==1) + 
                                          (ksads_23_958_t==1) + (ksads_23_959_t==1) + (ksads_23_960_t==1) + 
                                          (ksads_23_961_t==1),"past","never")), 
	                            levels = c("never", "present", "past")))


abcd_data<- abcd_data %>%
	    mutate(SI_ever_p = factor(if_else(0 < (ksads_23_946_p==1) + (ksads_23_947_p==1) + (ksads_23_948_p==1) +
	                                      (ksads_23_949_p==1) + (ksads_23_950_p==1), "present", 
	                                    if_else(0 < (ksads_23_957_p==1) + (ksads_23_958_p==1) + (ksads_23_959_p==1) +
                                          (ksads_23_960_p==1) + (ksads_23_961_p==1),"past","never")), 
	                            levels = c("never", "present", "past")))

##### Begin deletion section #####
#This is my attempt at working around the NAs, but it is not working
# abcd_data<- abcd_data %>%
# 	    mutate(SI_ever_p_t = factor(ifelse(is.na(SI_ever_p), SI_ever_t,
# 	                                        ifelse(is.na(SI_ever_t), SI_ever_p,
# 	                                                ifelse(SI_ever_p == "present" | SI_ever_t == "present",
# 	                                                        "present",
# 	                                                        ifelse(SI_ever_p == "past" | SI_ever_t == "past",
# 	                                                        "past", "never")))),
# 	                                 levels = c("never", "present", "past")))
# 	           
# 
# #this is the code that Chloe had, which does not work around the NAs (you can see there are many NAs in the composite variable). 
# abcd_data<- abcd_data %>%
# 	    mutate(SI_ever_p_t = factor(if_else(0 < (ksads_23_946_p==1) + (ksads_23_947_p==1) + (ksads_23_948_p==1) +
# 	                                      (ksads_23_949_p==1) + (ksads_23_950_p==1) + (ksads_23_946_t==1) +
# 	                                      (ksads_23_947_t==1) + (ksads_23_948_t==1) + (ksads_23_949_t==1) +
# 	                                      (ksads_23_950_t==1), "present", 
# 	                                    if_else(0 < (ksads_23_957_p==1) + (ksads_23_958_p==1) + (ksads_23_959_p==1) +
#                                           (ksads_23_960_p==1) + (ksads_23_961_p==1) + (ksads_23_957_t==1) + 
#                                           (ksads_23_958_t==1) + (ksads_23_959_t==1) + (ksads_23_960_t==1) + 
#                                           (ksads_23_961_t==1),"past","never")), 
# 	                            levels = c("never", "present", "past")))

### KAD 3/1: Here is my not very elegant solution (assuming that you want a parent OR child report of "present" to supersede a parent OR child report of "past" and for those to supersede a parent or child report of "never", but perhaps I'm misunderstanding)
# I got the same issue with NAs in the nested ifelse statements, and couldn't resolve it without adding in a million more NA checks, so I decided this very basic approach was actually easier to read
# But I will concede that this definitely does seem like a great use of case_when() so if Mark is able to easily provide that solution at some point it might be preferable! Or I can try to tackle it
##### End deletion section #####

abcd_data$SI_ever_p_t <- rep(NA,nrow(abcd_data))
abcd_data[which(abcd_data$SI_ever_p == "never" | abcd_data$SI_ever_t == "never"),]$SI_ever_p_t <- "never"
abcd_data[which(abcd_data$SI_ever_p == "past" | abcd_data$SI_ever_t == "past"),]$SI_ever_p_t <- "past"
abcd_data[which(abcd_data$SI_ever_p == "present" | abcd_data$SI_ever_t == "present"),]$SI_ever_p_t <- "present"
abcd_data$SI_ever_p_t <- factor(abcd_data$SI_ever_p_t, levels = c("never", "present", "past")) # Specifying the levels when setting the factor so it matches the others, otherwise past and present are switched, which probably doesn't matter since they're not ordered, but just for uniformity/if it gets used in code at some point across variables!

```

Remove the time points you do not want, rename the file with each time point removed
```{r Remove unwanted events}
# KAD 3/3/2023: Now just select the time points based on the list given by the user
abcd_data.selected_time <- abcd_data[which(abcd_data$eventname %in% timepoint_list),]

##### Begin deletion section #####
# KAD 3/3/2023: I will comment out the below in the final version, just wanted Mark to see it as is in case I'm missing something! For now running it won't cause any issues
table(abcd_data$eventname) #This will tell you the time points currently included in the data 
##### End deletion section #####

#Below is code to remove all six month time points:
abcd_data.1 <- abcd_data[abcd_data$eventname != "42_month_follow_up_arm_1",]
abcd_data.2 <- abcd_data.1[abcd_data.1$eventname != "30_month_follow_up_arm_1",]
abcd_data.3 <- abcd_data.2[abcd_data.2$eventname != "18_month_follow_up_arm_1",]
abcd_data.4 <- abcd_data.3[abcd_data.3$eventname != "6_month_follow_up_arm_1"]


```


Write your own file to merge with your other variables of interest
```{r write dataset}
# KAD 3/3/2023: Modifying Andrea's below code based on user input
# Create name based on date and initials/string passed in by user. If no date given, use the current date
if(is.null(out_date)){
  out_date <- Sys.Date()
}
# If no initials/string is given, throw an error that user must input one
if(is.null(out_initials)){
  stop("No input given for 'out_initials'. User must provide string input to create output file name.")
}
# Now output file based on name and out_dir given. Recall that if out_dir is NULL, it will write to current wd
csv_out_name <- paste0(out_dir,'/',out_date,'_',out_initials,'.csv')
write.csv(abcd_data.selected_time, csv_out_name)

##### Begin deletion section #####
# KAD 3/3/2023: Commenting this out in case someone runs the chunk -- it will error
#write.csv(abcd_data.X, "[Date]_[YourInitials].csv") #Update X based on whatever dataset version you are on
##### End deletion section #####
```


Reformat to wide data if desired
```{r wide}
# Get desired variables to put into wide format based on user input
# If user input is NULL, just use ALL variables from abcd_data
if(is.null(wide_vars)){
  wide_vars <- colnames(abcd_data)
}

# Now only doing wide format if it was set to TRUE above. If set to FALSE, nothing will happen
if(wide){
  
  # Initialize list to store data frames for each time point in
  data_years <- vector("list", length(timepoint_list))
  
  # Now loop through time points
  for(t in 1:length(timepoint_list)){
    tp <- timepoint_list[t]
    data_tp <- abcd_data[abcd_data$eventname == tp,]
    data_tp <- data_tp %>% select(subjectkey, all_of(wide_vars)) # Note that I'm using all_of() due to a tidyverse warning I don't really understand - someone should change it if they know better! 
    # Another note that it doesn't seem that duplicating "subjectkey" here is a problem, but again, if a tidyverse user knows better, they should fix it!
    
    names(data_tp) <- paste0(names(data_tp),"_",tp)
    data_tp <- dplyr::rename(data_tp, subjectkey = paste0('subjectkey','_',tp)) #rename subjectkey to maintain consistency across time points for merging
    
    # Save in data_years list
    data_years[[t]] <- data_tp
  }
  
  # Now merge all together
  abcd_wide <- data_years %>% reduce(full_join, by = "subjectkey")
  
  # Now output file based on initials and date input given (or for date, created in above chunk) and out_dir given
  # Recall that if out_dir is NULL, it will write to current wd
  csv_out_name_wide <- paste0(out_dir,'/',out_date,'_',out_initials,'_wide','.csv')
  write.csv(abcd_wide, csv_out_name_wide)
}

#### SEE CHUNK BELOW FOR ANDREA'S CODE THAT I BASED THIS ON ####
# Separating out into two chunks so both can be ran and compared #
```

```{r  Wide format if desired}
#### BELOW IS ANDREA'S CODE THAT I BASED THE ABOVE ON
#-----------------------------------------------------
#     Be sure to paste all variable names
#     to be included at each time point into
#     the "select()" call for each data subset
#------------------------------------------------------

data_BL <- abcd_data[abcd_data$eventname == "baseline_year_1_arm_1",]
data_BL <- data_BL %>%
  select(subjectkey, ) #enter all of the variable names you'd like pulled from BL into the list within parentheses
names(data_BL) <- paste(names(data_BL), "_BL", sep = "")
data_BL <- dplyr::rename(data_BL, subjectkey = subjectkey_BL) #rename subjectkey to maintain consistency across time points for merging

data_Y1 <- abcd_data[abcd_data$eventname == "1_year_follow_up_y_arm_1",]
data_Y1 <- data_Y1 %>%
  select(subjectkey, ) #enter all of the variable names you'd like pulled from Year 1
names(data_Y1) <- paste(names(data_Y1), "_Y1", sep = "")
data_Y1 <- dplyr::rename(data_Y1, subjectkey = subjectkey_Y1) #rename subjectkey to maintain consistency across time points for merging

data_Y2 <- abcd_data[abcd_data$eventname == "2_year_follow_up_y_arm_1",]
data_Y2 <- data_Y2 %>%
  select(subjectkey, ) #enter all of the variable names you'd like pulled from Year 2
names(data_Y2) <- paste(names(data_Y2), "_Y2", sep = "")
data_Y2 <- dplyr::rename(data_Y2, subjectkey = subjectkey_Y2) #rename subjectkey to maintain consistency across time points for merging

data_Y3 <- abcd_data[abcd_data$eventname == "3_year_follow_up_y_arm_1",]
data_Y3 <- data_Y3 %>%
  select(subjectkey, ) #enter all of the variable names you'd like pulled from Year 2
names(data_Y3) <- paste(names(data_Y3), "_Y3", sep = "")
data_Y3 <- dplyr::rename(data_Y3, subjectkey = subjectkey_Y3) #rename subjectkey to maintain consistency across time points for merging

#--------------------------------------------------------
#  Can repeat for any additional data time points needed (e.g., 18 mo follow up) 
# Below is code for merging and writing the file 
#--------------------------------------------------------

data_years <- list(data_BL, data_Y1, data_Y2, data_Y3)
abcd_wide <- data_years %>% reduce(full_join, by = "subjectkey")

#To double check that there are no errors (e.g., no repeats of a grid since all individuals should have one row)
length(unique(abcd_wide$subjectkey)) == nrow(abcd_wide) #Should return "TRUE", if returns FALSE, there is a duplicate row and troubleshooting is needed.

#Write yourself a file to use for your project
write.csv(abcd_wide, "[Date]_[YourInitials].csv")

```

